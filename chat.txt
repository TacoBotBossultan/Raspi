use tracing::{info, error};
use tracing_subscriber::fmt::writer::BoxMakeWriter;
use tracing_subscriber::fmt::time::UtcTime;
use tracing_subscriber::fmt::writer::MakeWriterExt;

fn main() {
    // Configure non-blocking output to stdout and stderr
    let (stdout_writer, stdout_guard) = tracing_appender::non_blocking(std::io::stdout());
    let (stderr_writer, stderr_guard) = tracing_appender::non_blocking(std::io::stderr());

    // Combined writer: INFO and below to stdout, WARN and above to stderr
    let combined_writer = BoxMakeWriter::new(stdout_writer.with_max_level(tracing::Level::INFO))
        .or_else(stderr_writer.with_min_level(tracing::Level::WARN));

    tracing_subscriber::fmt()
        .with_writer(combined_writer)
        .with_timer(UtcTime::rfc_3339())
        .init();

    // Spawn threads
    std::thread::scope(|s| {
        for i in 0..4 {
            s.spawn(move || {
                for j in 0..5 {
                    if j % 2 == 0 {
                        info!("thread {i} says hello #{j}");
                    } else {
                        error!("thread {i} says uh-oh #{j}");
                    }
                }
            });
        }
    });

    // Drop guards to flush async buffers before exit
    drop(stdout_guard);
    drop(stderr_guard);
}

